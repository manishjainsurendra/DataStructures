// Prime Number


Scanner sc =new Scanner(System.in);
       int start = sc.nextInt();
       int end = sc.nextInt();

       int i,j;
       for(i=start;i<=end;i++){
           //System.out.println(Math.sqrt(i));
           for(j=2;j<=Math.round(Math.sqrt(i));j++){

               if(i%j == 0){
                   //System.out.println("notprime");
                   break;
               }
           }
           if(j>Math.sqrt(i)){
               System.out.println(i);
           }

       }


// Factorial


int n = sc.nextInt();
        int start = sc.nextInt();
        int start1=start;
        int i,temp=1;
        //int[] factors = new int[n+1];
        while(start>1){
            temp *=start;
            start--;
        }
        System.out.println(temp);
        for(i=start1+1;i<=n;i++){
            temp *= i;
            System.out.println(temp);
        }


// stack implementation

package com.company;
import java.util.*;
class MyStack {
    int[] arr ;
    int top;
    // constructor
    public MyStack(int capacity){
        this.arr = new int[capacity];
        this.top = -1;
    }
    // push into stack
    public void push (int item){
        if(this.top == this.arr.length-1){
            System.out.println("overflow");
        }
        this.top++;
        this.arr[top] = item;
    }
    //delete element from stack
    public int pop (){
        if(this.top==-1){
            System.out.println("underflow");
        }
        int item = this.arr[top];
        this.top--;
        return item;
    }
    // return top element
    public int peek(){
        if(this.top ==-1){
            System.out.println("stack is empty");
            return -1;
        }
        else
        return this.arr[top];
    }
    // print stack elements
    public void print(){
            System.out.println(Arrays.toString(this.arr));
    }
}
public class Main {

    public static void main(String[] args) {
	// write your code here
        Scanner sc =new Scanner(System.in);
        System.out.print("enter capacity:");
        int capacity = sc.nextInt();

        MyStack stack1 = new MyStack(capacity);
        int cmd=0;
        while(cmd!=5){

            System.out.println("Select Operation");
            System.out.println("1.Push");
            System.out.println("2.Pop");
            System.out.println("3.peek");
            System.out.println("4.print");
            System.out.println("5.Exit");
           cmd = sc.nextInt();

           if(cmd==1){
               int element = sc.nextInt();
               stack1.push(element);
           }
           else if(cmd==2){
               int element = stack1.pop();
               System.out.println("popped: " + element );
           }
           else if(cmd==3){
               System.out.println("top element: " + stack1.peek());
           }
           else if(cmd==4){
               stack1.print();
           }
           else {
               System.out.println("Exited successfully");
           }

        }
//

    }
}


// infix to postfix
Q (inout infix expression)
P(postifix)
    function Polish(Q,P){
   1.add "left" paranthesis onto stack      prefix - "right"
    add right  paranthesis at end of "Q"    prefix - "left" at begin of "Q"  
  2. for each of Q
     left to right             prefix  - right to left
     repeat steps 3 to 6 until stack is empty
  3. if "("  => push it onto stack       prefix - if ")" => push it onto stack
  4.if an operand => add it to Postfix "P" prefix - same 
  5.if an operator  => 
    i. repeatedly pop from stack, all the operators that have same or higher precedence than current operator or "("     prefix - and pop only higher precedence than current    
    ii. add the current operator to the stack           
    iii. place all the popped operators to the postfix "P"

  6. if a ")" =>         prefix - if a "(" 
    i. repeatedly pop from stack all the operators until a "("          prefix -  until a ")"
    ii. remove the "("         prefix - remove the ")"
    iii. add all the popped to "P"   
 
 
  7.exit      prefix - reverse the prefix expresion and exit  

}


// evaluate postfix 
P - postfix 


1.add ")" at the end of "P"   prefix - add "(" 
2. scan "P" from "left to right" and repeat steps 3 and 4 for each element of "P" until ")" is encountered          prefix - "right to left"     until "(" is encountered
3.if an operand =>
  push it onto stack        

4. if an operator is encountered
  i. pop top two elements 
     A- top element B- second top element
     
  ii.Perform "B operator A" and push to stack               prefix -"A operator B"    

5. set result = top most value on the stack    
6. exit 



//infix to postfix 

package com.company;
import java.util.*;
class MyStack {

    //delete element from stack
    public int precedence (String op){
        if(op.equals("^")){
            return 3;
        }
        else if(op.equals("/") || op.equals("*")){
            return 2;
        }
        else if(op.equals("+") || op.equals("-")){
            return 1;
        }
        else if(op.equals("(")){
            return -1;
        }
        else
            return 0;
    }
}
public class Main {

    public static void main(String[] args) {
	// write your code here
        Scanner sc =new Scanner(System.in);
        System.out.print("enter infix expression:");
        String infix = sc.next();
        String Postfix = new String();
        Stack<String> P = new Stack<String>();
        String[] operators = {"+","*","/","-","^"};
        MyStack stack1 = new MyStack();
        List<String> list = Arrays.asList(operators);
        int i;
        P.push("(");
        //System.out.println(P);
        infix = infix + ")";
        for(i=0;i<infix.length();i++){
            if(String.valueOf(infix.charAt(i)).equals("(")){
                P.push("(");
            }
            else if(String.valueOf(infix.charAt(i)).equals(")")){
                String temp = new String();
                while(!P.peek().equals("(")) {
                    temp = P.pop();
                    Postfix = Postfix + temp;
                    //System.out.println(Postfix);
                }
                P.pop();
                }
            else if(list.contains(String.valueOf(infix.charAt(i)))){
                String peek = P.peek();
                String temp = new String();
                int current = stack1.precedence(String.valueOf(infix.charAt(i)));
                //System.out.println(current);
                //System.out.println(stack1.precedence(peek));
                while(stack1.precedence(String.valueOf(infix.charAt(i))) <= stack1.precedence(P.peek())){
                    temp = P.pop();
                    Postfix = Postfix + temp;
                    System.out.println(Postfix);
                }

                P.push(String.valueOf(infix.charAt(i)));
            }
            else {
                //System.out.println("A");
                Postfix = Postfix + String.valueOf(infix.charAt(i));
            }
            System.out.println(P);
        }
        System.out.println(Postfix);

    }
}



// circular queue

package com.company;
import java.util.*;
class MyQueue {
    int[] arr ;
    int front,rear;
    // constructor
    public MyQueue(int capacity){
        this.arr = new int[capacity];
        this.front = -1;
        this.rear = -1;
    }
    public void enqueue (int item){
        if((this.rear+1)%this.arr.length == this.front){
            System.out.println("overflow");
            return;
        }
        if(this.front==-1 && this.rear ==-1)
            this.front++;

        this.rear = (this.rear+1)%this.arr.length;
        this.arr[this.rear] = item;
    }
    //delete element from stack
    public int dequeue (){
        if(this.front==-1){
            System.out.println("underflow");
            return -1;
        }
        if(this.front == this.rear){
            int item = this.arr[this.front];
            this.front=this.rear=-1;
            return item;
        }
        int item = this.arr[this.front];
        this.front= (this.front+1)%this.arr.length;
        return item;
    }
   //print Queue elements
    public void print(){


        if(this.rear < this.front){
            for(int i=this.front;i<this.arr.length;i++) {
                System.out.print(arr[i]+"\t");
            }
            for(int i=this.rear;i<this.front;i++) {
                System.out.print(arr[i]+"\t");
            }
            return;
        }
        for(int i=this.front;i<=this.rear;i++) {
            System.out.print(arr[i]+"\t");
        }
    }

}
public class Main {

    public static void main(String[] args) {
	// write your code here
        Scanner sc =new Scanner(System.in);
        System.out.print("enter capacity of queue:");
        int capacity = sc.nextInt();
        int cmd=0;
        MyQueue queue1 = new MyQueue(capacity);
        while(cmd!=4){
            System.out.println("1.Insert");
            System.out.println("2.Delete");
            System.out.println("3.Display");
            System.out.println("4.Exit");
            cmd = sc.nextInt();
            if(cmd==1){
                int element = sc.nextInt();
                queue1.enqueue(element);
            }
            else if(cmd==2){
                int element = queue1.dequeue();
                System.out.println(element);
            }
            else if(cmd==3){
                queue1.print();
            }
            else {
                System.out.println("exited sucessfully");
            }

        }
    }
}



//DEQUeue(Double ended queue)

package com.company;
import java.util.*;
class MyQueue {
    int[] arr ;
    int left,right;
    // constructor
    public MyQueue(int capacity){
        this.arr = new int[capacity];
        this.left = -1;
        this.right = -1;
    }
    public void insertright (int item){
        if((this.right+1)%this.arr.length == this.left){
            System.out.println("overflow");
            return;
        }
        if(this.left==-1 && this.right ==-1)
            this.left++;

        this.right = (this.right+1)%this.arr.length;
        this.arr[this.right] = item;
    }
    public void insertleft (int item){
        if((this.right+1)%this.arr.length == this.front){
            System.out.println("overflow");
            return;
        }
        if(this.left==-1 && this.right ==-1)
            this.left =this.right = this.arr.length-1;
         else if(this.left==0){
            this.left=this.arr.length-1;
        }   
        else
        this.left = this.left-1;
        
        this.arr[this.left] = item;
    }
    //delete element from stack
    public int deleteleft (){
        if(this.left==-1){
            System.out.println("underflow");
            return -1;
        }
        if(this.left == this.right){
            int item = this.arr[this.left];
            this.left=this.right=-1;
            return item;
        }
        int item = this.arr[this.left];
        this.left= (this.left+1)%this.arr.length;
        return item;
    }
    public int deleteright (){
        if(this.left==-1){
            System.out.println("underflow");
            return -1;
        }
        if(this.left == this.right){
            int item = this.arr[this.right];
            this.left=this.right=-1;
            return item;
        }
        int item = this.arr[this.right];
        if(this.right ==0 ){
            this.right = this.arr.length-1;
        }
        else
        this.right= this.right-1;
        return item;
    }
   //print Queue elements
    public void print(){


        if(this.right < this.left){
            for(int i=this.left;i<this.arr.length;i++) {
                System.out.print(arr[i]+"\t");
            }
            for(int i=this.right;i<this.left;i++) {
                System.out.print(arr[i]+"\t");
            }
            return;
        }
        for(int i=this.left;i<=this.right;i++) {
            System.out.print(arr[i]+"\t");
        }
    }

}
public class Main {

    public static void main(String[] args) {
	// write your code here
        Scanner sc =new Scanner(System.in);
        System.out.print("enter capacity of queue:");
        int capacity = sc.nextInt();
        int cmd=0;
        MyQueue queue1 = new MyQueue(capacity);
        while(cmd!=4){
            System.out.println("1.Insert");
            System.out.println("2.Delete");
            System.out.println("3.Display");
            System.out.println("4.Exit");
            cmd = sc.nextInt();
            if(cmd==1){
                int element = sc.nextInt();
                queue1.enqueue(element);
            }
            else if(cmd==2){
                int element = queue1.dequeue();
                System.out.println(element);
            }
            else if(cmd==3){
                queue1.print();
            }
            else {
                System.out.println("exited sucessfully");
            }

        }
    }
}



//Priority Queue

package com.company;
import java.util.*;
class Item {
    int number;
    int priority;
    Item(int n,int p) {
        number = n;
        priority = p;
    }
}
class MyQueue {
    Item[] item;
    int front,rear,index=0,i;
    public MyQueue(int capacity){
        this.item = new Item[capacity];
        this.front = -1;
        this.rear = -1;
    }

    public void enqueue (int number,int priority){
        if((this.rear+1)%this.item.length == this.front){
            System.out.println("overflow");
            return;
        }
        if(this.front==-1 && this.rear ==-1){
            this.front++;
            this.rear++;
            this.item[this.rear] = new Item(number,priority);

        }

        else {
            this.rear = (this.rear+1) % this.item.length;
            System.out.println(this.rear);
            if (this.rear > this.front) {
                for (i = this.rear - 1; i >= this.front; i--) {
                    int index;
                    System.out.println(this.item[i].priority);
                    if (this.item[i].priority < priority) {
                        this.item[i + 1] = this.item[i];
                        continue;
                    } else if (this.item[i].priority >= priority) {
                        index = i + 1;
                        break;
                    }

                }
                this.item[index] = new Item(number, priority);

            } else if (this.rear < this.front) {
                for (i = this.rear - 1; i >= 0; i--) {
                    int index;
                    if (this.item[i].priority < priority) {
                        this.item[i + 1] = this.item[i];
                        continue;
                    } else if (this.item[i].priority >= priority) {
                        index = i + 1;
                        break;
                    }

                }
                if (i == -1) {
                    this.item[0] = this.item[this.item.length - 1];
                    for (int i = this.item.length - 2; i >= this.front; i--) {
                        int index;
                        if (this.item[i].priority < priority) {
                            this.item[i + 1] = this.item[i];
                            continue;
                        } else if (this.item[i].priority >= priority) {
                            index = i + 1;
                            break;
                        }

                    }
                }
                this.item[index] = new Item(number, priority);
            }
        }
    }
    //delete element from stack
    public Item dequeue (){
        if(this.front==-1){
            System.out.println("underflow");
            return null;
        }
        if(this.front == this.rear){
            Item items = this.item[this.front];
            this.front=this.rear=-1;
            return items;
        }
        Item items = this.item[this.front];
        this.front= (this.front+1)%this.item.length;
        return items;
    }
    //print Queue elements
//    public void print(){
//
//
//        if(this.rear < this.front){
//            for(int i=this.front;i<this.arr.length;i++) {
//                System.out.print(arr[i]+"\t");
//            }
//            for(int i=this.rear;i<this.front;i++) {
//                System.out.print(arr[i]+"\t");
//            }
//            return;
//        }
//        for(int i=this.front;i<=this.rear;i++) {
//            System.out.print(arr[i]+"\t");
//        }
//    }


}
public class Main {

    public static void main(String[] args) {
	// write your code here
        Scanner sc =new Scanner(System.in);
        System.out.print("enter capacity of queue:");
        int capacity = sc.nextInt();
        int cmd=0;
        MyQueue queue1 = new MyQueue(capacity);
        while(cmd!=4){
            System.out.println("1.Insert");
            System.out.println("2.Delete");
            System.out.println("3.Display");
            System.out.println("4.Exit");
            cmd = sc.nextInt();
            if(cmd==1){
                int element = sc.nextInt();
                int priority = sc.nextInt();
                queue1.enqueue(element,priority);
            }
            else if(cmd==2){
                Item element = queue1.dequeue();
                System.out.println(element.priority);
            }
//            else if(cmd==3){
//                queue1.print();
//            }
            else {
                System.out.println("exited sucessfully");
            }

        }
    }
}

// Singly Linked List

package com.company;
import java.util.*;

class MyLinkedList {

    class Node{
        int data;
        Node next;
    };
    Node head=null;
    public void insertFirst(int element){
        Node temp=new Node();
        temp.data = element;
        temp.next=head;
        head = temp;
    }
    public void insert(int element){
        Node temp = head;
        if(temp==null){
            insertFirst(element);
            return;
        }
        while(temp.next!=null){
            temp = temp.next;
        }
        Node q = new Node();
        q.data = element;
        q.next = null;
        temp.next=q;
    }
    public void insertAfter(int a,int b){
        Node temp = head;
        if(temp==null){
            System.out.println("not possible, empty ll");
            return;
        }
        while(temp.next!=null && temp.data!=b){
            temp = temp.next;
        }
        if(temp.next == null && temp.data !=b){
            System.out.println("node not present");
            return;
        }
        Node q = new Node();
        q.next = temp.next;
        q.data = a;
        temp.next = q;

    }
    public void insertBefore(int a,int b){
        Node temp = head;
        if(temp==null){
            System.out.println("not possible, empty ll");
            return;
        }
        if(temp.data == b){
            insertFirst(a);
            return;
        }
        while(temp.next!=null && temp.next.data!=b){
            temp = temp.next;
        }
        if(temp.next == null){
            System.out.println("node not present");
            return;
        }
        Node q = new Node();
        q.next = temp.next;
        q.data = a;
        temp.next = q;

    }
    public void insertSorted(int element){
        Node temp = head;
        if(temp==null){
            insertFirst(element);
            return;
        }
        while(temp.next!=null && temp.data<element){
            temp = temp.next;
        }
        if(temp.data <= element && temp.next == null){
            insert(element);
            return;
        }
        int ib = temp.data;
        insertBefore(element,ib);
        display();
    }
    public void deleteFirst(){
        if(head == null){
            System.out.println("no elements");
            return;
        }
        head = head.next;
        display();
    }
    public void deleteLast(){
        Node temp = head;
        if(temp==null){
            System.out.println("no elements");
            return;
        }
        while(temp.next.next!=null){
            temp = temp.next;

        }
        temp.next = null;
        display();
    }
    public void deleteElement(int element){
        Node temp = head;
        if(temp==null){
            System.out.println("no elements");
            return;
        }
        while(temp.next!=null && temp.next.data!=element){
            temp = temp.next;
        }
        if(temp.next == null){
            System.out.println("element not found");
            return;
        }
        temp.next = temp.next.next;
        display();

    }
    public int deleteAfter(int element){
        int ele=-1;
        Node temp = head;
        if(temp==null){
            System.out.println("no elements");
            return -1;
        }
        while(temp.next!=null && temp.data!=element){
            temp = temp.next;
        }
        if(temp.next == null && temp.data==element){
            System.out.println("no elements to delete after given element");
            return -1;
        }
         ele = temp.next.data;
        temp.next = temp.next.next;

        return ele;
    }
    public int deleteBefore(int element){
        int ele=-1;
        Node temp = head;
        if(temp==null){
            System.out.println("no elements");
            return -1;
        }
        while(temp.next!=null && temp.next.next!=null && temp.next.data!=element &&  temp.next.next.data!=element){
            temp = temp.next;
        }
        if(temp.next==null || temp.data == element){
            System.out.println("no elements to delete");
            return -1;
        }
        if(temp.next.next == null || temp.next.data == element) {
            ele = temp.data;

            head = head.next;
            return ele;
        }
        temp = temp.next;
        ele = temp.data;
        temp.next = temp.next.next;

        return ele;
    }
    public int searchElement(int element){
        Node temp = head;
        int index=0;
        if(temp==null){
            System.out.println("no elements");
            return -1;
        }
        while(temp.next!=null && temp.data!=element){
            temp = temp.next;
            index++;
        }
        if(temp.data != element && temp.next == null){
            System.out.println("not found");
            return -1;
        }

        return index;
    }
    public void display(){
        Node temp = head;
        while(temp.next !=null){
            System.out.print(temp.data+"\t");
            temp = temp.next;
        }

        System.out.print(temp.data);
        System.out.println("");
    }
}
public class Main {

    public static void main(String[] args) {
	// write your code here
        Scanner sc =new Scanner(System.in);

        int cmd=0;
        MyLinkedList linklist = new MyLinkedList();
        while(cmd!=13){
            System.out.println("1.Insert");
            System.out.println("2.InsertFirst");

            System.out.println("3.Display");
            System.out.println("4.Insert After");
            System.out.println("5.Insert Before");
            System.out.println("6.Delete First");
            System.out.println("7.Delete Last");
            System.out.println("8.Delete Element");
            System.out.println("9.Delete Before");
            System.out.println("10.Delete After");
            System.out.println("11.Search element");
            System.out.println("12.insert sorted");

            System.out.println("13.Exit");
            cmd = sc.nextInt();
            if(cmd==1){
                int element = sc.nextInt();

                linklist.insert(element);
            }
            else if(cmd==2){
                int element =  sc.nextInt();
                linklist.insertFirst(element);
            }
            else if(cmd==3){
                linklist.display();
            }
            else if(cmd==4){
                int element1 =  sc.nextInt();
                int element2 =  sc.nextInt();
                linklist.insertAfter(element1,element2);
            }
            else if(cmd==5){
                int element1 =  sc.nextInt();
                int element2 =  sc.nextInt();
                linklist.insertBefore(element1,element2);
            }
            else if(cmd==6){
                linklist.deleteFirst();
            }
            else if(cmd==7){
                linklist.deleteLast();
            }
            else if(cmd==8){
                int element = sc.nextInt();
                linklist.deleteElement(element);
            }
            else if(cmd==9){
                int element = sc.nextInt();
                int ele = linklist.deleteBefore(element);
                System.out.println(ele+"deleted successfully");
                linklist.display();
            }
            else if(cmd==10){
                int element = sc.nextInt();
                int ele = linklist.deleteAfter(element);
                System.out.println(ele+"deleted successfully");
                linklist.display();
            }
            else if(cmd==11) {
                int element = sc.nextInt();
               int index =  linklist.searchElement(element);
                System.out.println("found at" +index);
            }
            else if(cmd==12) {
                int element = sc.nextInt();
                linklist.insertSorted(element);
            }
            else {
                System.out.println("exited sucessfully");
            }

        }
    }
}



// doubly circular linked list

class MyDoubleLinkedList {

    class Node{
        int data;
        Node next,prev;
    };
    Node header,tail;
    public void headerNode(){
        header=new Node();
        header.data = 0;
        header.prev = null;
        header.next = null;
    }
    public void tailNode(){
        tail=new Node();
        tail.data = 0;
        tail.prev = null;
        tail.next = header.next;
    }
    public MyDoubleLinkedList(){
        headerNode();
        tailNode();
    }

    public void insertFirst(int element){
        Node temp=new Node();
        temp.data = element;
        temp.next=header.next;
        temp.prev = tail;
        tail.next = temp;
        header.next = temp;
        header.data++;
        if(header.data == 1){

            temp.prev = temp;
            tail=temp;
            //tail.next = header.next;
        }

    }
    public void insert(int element){
        Node temp = header.next;
        if(temp==null){
            insertFirst(element);
            return;
        }
        while(temp.next!=tail.next){
            temp = temp.next;
        }
        Node q = new Node();
        q.data = element;
        q.next = header;
        temp.next=q;
        q.prev =temp;
        tail=q;
        header.data++;

    }
    public void insertAfter(int a,int b){
        Node temp = header.next;
        if(temp==null){
            System.out.println("not possible, empty ll");
            return;
        }
        while(temp.next!=tail.next && temp.data!=b){
            temp = temp.next;
        }
        if(temp.next == tail.next && temp.data !=b){
            System.out.println("node not present");
            return;
        }
        Node q = new Node();
        q.next = temp.next;
        q.data = a;
        q.prev=temp;
        temp.next.prev = q;
        temp.next = q;
        header.data++;

    }
    public void insertBefore(int a,int b){
        Node temp = header.next;
        if(temp==null){
            System.out.println("not possible, empty ll");
            return;
        }
        if(temp.data == b){
            insertFirst(a);
            return;
        }
        while(temp.next!=tail.next && temp.data!=b){
            temp = temp.next;
        }
        if(temp.next == tail.next){
            System.out.println("node not present");
            return;
        }
        Node q = new Node();
        q.next = temp;
        q.prev = temp.prev;
        q.data = a;
        temp.prev.next = q;
        temp.prev = q;
        header.data++;

    }
//    public void insertSorted(int element){
//        Node temp = head;
//        if(temp==null){
//            insertFirst(element);
//            return;
//        }
//        while(temp.next!=null && temp.data<element){
//            temp = temp.next;
//        }
//        if(temp.data <= element && temp.next == null){
//            insert(element);
//            return;
//        }
//        int ib = temp.data;
//        insertBefore(element,ib);
//        display();
//    }
    public void deleteFirst(){
        if(header.next == null){
            System.out.println("no elements");
            return;
        }
        header.next = header.next.next;
        header.data--;
        tail.next = header.next;
        display();
    }


    public void deleteLast(){
       if(header.data >=1) {
           tail.prev.next = tail.next;
           tail = tail.prev;
           header.data--;
       }
       if(header.data == 0){
           System.out.println("no elements");
           return;
       }
        display();
    }
    public void deleteElement(int element){
        Node temp = header.next;
        if(temp==null){
            System.out.println("no elements");
            return;
        }
        while(temp.next!=tail.next && temp.data!=element){
            temp = temp.next;
        }
        if(temp.next == tail.next && temp.data!=element){
            System.out.println("element not found");
            return;
        }
        if(temp.next == tail.next && temp.data==element){
            deleteLast();
            return;
        }
        temp.prev.next = temp.next;
        temp.next.prev = temp.prev;
        header.data--;
        display();
    }
    public int deleteAfter(int element){
        int ele=-1;
        Node temp = header.next;
        if(temp==null){
            System.out.println("no elements");
            return -1;
        }
        while(temp.next!=tail.next && temp.data!=element){
            temp = temp.next;
        }
        if(temp.next == tail.next && temp.data!=element){
            System.out.println("element not found");
            return -1;
        }
        if(temp.next == tail.next && temp.data==element){
           ele = header.next.data;
            deleteFirst();
           return ele;
        }

        if(temp.next == tail){
            ele = tail.data;
            deleteLast();
            return ele;
        }
        ele = temp.next.data;

        temp.next = temp.next.next;
        temp.next.prev = temp;
        header.data--;



        return ele;
    }
    public int deleteBefore(int element){
        int ele=-1,count=0;
        Node temp = header.next;
        if(temp==null){
            System.out.println("no elements");
            return -1;
        }
        if(temp.data == element){
            ele = tail.data;
            deleteLast();
            return ele;
        }
        while(temp.next!=tail.next && temp.data!=element){
            temp = temp.next;
            count++;
        }
        if(temp.next==tail.next && temp.data != element){
            System.out.println("no elements to delete");
            return -1;
        }
        if(temp.next == tail.next &&  temp.data == element) {
            System.out.println("abc");
            ele = temp.prev.data;

            temp.prev = temp.prev.prev;
            temp.prev.next = temp;
            tail = temp;

            return ele;
        }
        if(temp.prev == header.next){
            //System.out.println("def");

            ele = temp.prev.data;
             deleteFirst();
             return ele;
        }
        ele = temp.prev.data;

        temp.prev = temp.prev.prev;
        temp.prev.next = temp;

        return ele;
    }
    public int searchElement(int element){
        Node temp = header.next;
        int index=0;
        if(temp==null){
            System.out.println("no elements");
            return -1;
        }
        while(temp.next!=tail.next && temp.data!=element){
            temp = temp.next;
            index++;
        }
        if(temp.data != element && temp.next == tail.next){
            System.out.println("not found");
            return -1;
        }

        return index;
    }
    public void display(){
        Node temp = header.next;
        while(temp.next !=tail.next){
            System.out.print(temp.data+"\t");
            temp = temp.next;
        }

        System.out.print(temp.data);
        System.out.println("");
    }
    public int noofelements(){

        return header.data;
    }
}

// Circular Queue using SLL

package com.company;
import java.util.*;

class MyDoubleLinkedList {

    class Node{
        int data;
        Node next,prev;
    };
    Node header,tail;
    public void headerNode(){
        header=new Node();
        header.data = 0;
        header.prev = null;
        header.next = null;
    }
    public void tailNode(){
        tail=new Node();
        tail.data = 0;
        tail.prev = null;
        tail.next = header.next;
    }
    public MyDoubleLinkedList(){
        headerNode();
        tailNode();
    }

    public void insertFirst(int element){
        Node temp=new Node();
        temp.data = element;
        temp.next=header.next;
        temp.prev = tail;
        tail.next = temp;
        header.next = temp;
        header.data++;
        if(header.data == 1){

            temp.prev = temp;
            tail=temp;
            //tail.next = header.next;
        }
       // System.out.println(tail.data);

    }
    public void insert(int element){
        Node temp = header.next;
        if(temp==null){
            insertFirst(element);
            return;
        }
        while(temp.next!=tail.next){
            temp = temp.next;
        }
        Node q = new Node();
        q.data = element;
        q.next = header;
        temp.next=q;
        q.prev =temp;
        tail=q;
        header.data++;

    }
    public void insertAfter(int a,int b){
        Node temp = header.next;
        if(temp==null){
            System.out.println("not possible, empty ll");
            return;
        }
        while(temp.next!=tail.next && temp.data!=b){
            temp = temp.next;
        }
        if(temp.next == tail.next && temp.data !=b){
            System.out.println("node not present");
            return;
        }
        Node q = new Node();
        q.next = temp.next;
        q.data = a;
        q.prev=temp;
        temp.next.prev = q;
        temp.next = q;
        header.data++;

    }
    public void insertBefore(int a,int b){
        Node temp = header.next;
        if(temp==null){
            System.out.println("not possible, empty ll");
            return;
        }
        if(temp.data == b){
            insertFirst(a);
            return;
        }
        while(temp.next!=tail.next && temp.data!=b){
            temp = temp.next;
        }
        if(temp.next == tail.next){
            System.out.println("node not present");
            return;
        }
        Node q = new Node();
        q.next = temp;
        q.prev = temp.prev;
        q.data = a;
        temp.prev.next = q;
        temp.prev = q;
        header.data++;

    }
//    public void insertSorted(int element){
//        Node temp = head;
//        if(temp==null){
//            insertFirst(element);
//            return;
//        }
//        while(temp.next!=null && temp.data<element){
//            temp = temp.next;
//        }
//        if(temp.data <= element && temp.next == null){
//            insert(element);
//            return;
//        }
//        int ib = temp.data;
//        insertBefore(element,ib);
//        display();
//    }
    public void deleteFirst(){
        if(header.next == null){
            System.out.println("no elements");
            return;
        }
        header.next = header.next.next;
        header.data--;
        tail.next = header.next;
        display();
    }


    public void deleteLast(){
       if(header.data >=1) {
           tail.prev.next = tail.next;
           tail = tail.prev;
           header.data--;
       }
       if(header.data == 0){
           System.out.println("no elements");
           return;
       }
        display();
    }
    public void deleteElement(int element){
        Node temp = header.next;
        if(temp==null){
            System.out.println("no elements");
            return;
        }
        while(temp.next!=tail.next && temp.data!=element){
            temp = temp.next;
        }
        if(temp.next == tail.next && temp.data!=element){
            System.out.println("element not found");
            return;
        }
        if(temp.next == tail.next && temp.data==element){
            deleteLast();
            return;
        }
        temp.prev.next = temp.next;
        temp.next.prev = temp.prev;
        header.data--;
        display();
    }
    public int deleteAfter(int element){
        int ele=-1;
        Node temp = header.next;
        if(temp==null){
            System.out.println("no elements");
            return -1;
        }
        while(temp.next!=tail.next && temp.data!=element){
            temp = temp.next;
        }
        if(temp.next == tail.next && temp.data!=element){
            System.out.println("element not found");
            return -1;
        }
        if(temp.next == tail.next && temp.data==element){
           ele = header.next.data;
            deleteFirst();
           return ele;
        }

        if(temp.next == tail){
            ele = tail.data;
            deleteLast();
            return ele;
        }
        ele = temp.next.data;

        temp.next = temp.next.next;
        temp.next.prev = temp;
        header.data--;



        return ele;
    }
    public int deleteBefore(int element){
        int ele=-1,count=0;
        Node temp = header.next;
        if(temp==null){
            System.out.println("no elements");
            return -1;
        }
        if(temp.data == element){
            ele = tail.data;
            deleteLast();
            return ele;
        }
        while(temp.next!=tail.next && temp.data!=element){
            temp = temp.next;
            count++;
        }
        if(temp.next==tail.next && temp.data != element){
            System.out.println("no elements to delete");
            return -1;
        }
        if(temp.next == tail.next &&  temp.data == element) {
            System.out.println("abc");
            ele = temp.prev.data;

            temp.prev = temp.prev.prev;
            temp.prev.next = temp;
            tail = temp;

            return ele;
        }
        if(temp.prev == header.next){
            //System.out.println("def");

            ele = temp.prev.data;
             deleteFirst();
             return ele;
        }
        ele = temp.prev.data;

        temp.prev = temp.prev.prev;
        temp.prev.next = temp;

        return ele;
    }
    public int searchElement(int element){
        Node temp = header.next;
        int index=0;
        if(temp==null){
            System.out.println("no elements");
            return -1;
        }
        while(temp.next!=tail.next && temp.data!=element){
            temp = temp.next;
            index++;
        }
        if(temp.data != element && temp.next == tail.next){
            System.out.println("not found");
            return -1;
        }

        return index;
    }
    public void display(){
        Node temp = header.next;
        while(temp.next !=tail.next){
            System.out.print(temp.data+"\t");
            temp = temp.next;
        }

        System.out.print(temp.data);
        System.out.println("");
    }
    public int noofelements(){

        return header.data;
    }
}

class CircularQueueUsingSll{
    class Node{
        int data;
        Node next;
    }
    Node header,tail;
    public void headerNode(){
        header=new Node();
        header.data = 0;
        header.next = null;
    }
    public void tailNode(){
        tail=new Node();
        tail.data = 0;
        tail.next = header.next;
    }
    public CircularQueueUsingSll(){
        headerNode();
        tailNode();
    }
    public void enqueue(int element){
        Node temp = new Node();
        temp.data = element;
        if(header.data == 0){
            temp.next = temp;
            tail=temp;
            header.next = temp;
        }
        else{
            temp.next = header.next;
            tail.next=temp;
            tail = temp;
        }
        header.data++;

    }
    public int dequeue(){


        if(header.data == 0){
            System.out.println("Queue is empty");
            return -1;
        }

        if(header.data == 1) {
            int ele = header.next.data;
            header.next = null;
            tail.next=null;
            header.data = 0;
            return ele;
        }
        int ele = header.next.data;
        header.next = header.next.next;
        tail.next = header.next;
        header.data--;
       return ele;
    }

    public void display(){
        Node temp = header.next;
        //System.out.println(temp.next.data);
        while(temp.next!=tail.next){
            System.out.print(temp.data +"\t");
            temp = temp.next;
        }
        System.out.println(temp.data);
    }

}
public class Main {

    public static void main(String[] args) {
	// write your code here
        Scanner sc =new Scanner(System.in);

        int cmd=0;
        CircularQueueUsingSll linklist = new CircularQueueUsingSll();
        while(cmd!=4){
            System.out.println("1.Enqueue");
            System.out.println("2.Dequeue");

            System.out.println("3.Display");



            System.out.println("4.Exit");
            cmd = sc.nextInt();
            if(cmd==1){
                int element = sc.nextInt();

                linklist.enqueue(element);
            }
            else if(cmd==2){
                int element =  linklist.dequeue();
                System.out.println(element+" deleted successfully");
            }
            else if(cmd==3){
                linklist.display();
            }

            else {
                System.out.println("exited sucessfully");
            }

        }
    }
}

// Radix Sort

public class Main {
    public static int maxElement(int[] b){
        int max=0,i=0;
        while(i<b.length){
            if(b[i]>max){
                max=b[i];
            }
            i++;
        }
        return max;
    }
    public static int[] radix(int[] b,int noOfDigits){
        int[] c = new int[b.length];
        int[][] d = new int[10][b.length];
        int[] counter = new int[10];
        int decplace = 1;
        int i,j,k,l;
        while(noOfDigits>0){
            for(i=0;i<b.length;i++){
                int temp = b[i],pos=0;
                int decplaces = decplace;
                while(decplaces>0){
                    pos = temp%10;
                    temp=temp/10;
                    decplaces--;
                }


                if(pos>10){
                    pos=0;
                }
                d[pos][counter[pos]] = b[i];
                counter[pos]++;
            }

            l=0;
            for(j=0;j<9;j++){
                for(k=0;k<counter[j];k++){
                    b[l] = d[j][k];
                    l++;
                }
                counter[j]=0;
            }
            for(l=0;i<9;l++){
                counter[l]=0;
            }
            noOfDigits--;
            decplace +=1;
        }


        return b;
    }
    public static void main(String[] args) {
	// write your code here

        int []arr = {100,55,28,421,124,56,86,6,4,1000,45,1,2,3,10,20,30,48,250,300,0,0};
        int max = maxElement(arr);
        System.out.println(max);
        int noOfDigitsMax = 0;
        int max1=max;
        while(max1>0){
            max1 = max1 /10;
            noOfDigitsMax++;
        }
        System.out.println(Arrays.toString(arr) + noOfDigitsMax);
        arr = radix(arr,noOfDigitsMax);
        System.out.println(Arrays.toString(arr));
    }
}

// hashing 
hash size 100(00-99)
input 3205,7148,2345
1. modulus method

2. midsquare method 

 k                k^2
3205            10272025
7148            51093904
2345            5499025
  

  select any two bits consecutive from k^2(same for all)
suppose we take 4th and 5th from right(starts from 1)
for 10272025 -  4th - 2 5th - 7 hash - 72
 k                k^2           hash 
3205            10272025         72
7148            51093904         93
2345            5499025          99


 3. folding method - (Chopping/Hashing)

H(3205) = 32 + 05 = 37 (selecting two digtits at a time since hash range is 00 to 99)

H(7148) = 71 + 48 = 119 (ignore carry)  = 19

H(2345) = 23 + 45 = 68

H(0108) = 01 + 08 = 09
H(32051) = 32 +05 +1 = 38



collision resolution
OPen addressing
1.linear probing
2.quadratic probing
3.Double Hashing


// hashing with linear probing

class Record{
    int key;
    String val;
    Record(int key,String val){
        this.key = key;
        this.val = val;
    }
    Record(){
        this.key=0;
        this.val="";
    }
    public int search(int key,Record[] hashTable){
        int hash = key%17;
        int start=hash-1;
        if(hashTable[hash].key == key){
            return hash;
        }
        while(hashTable[hash].key != key && hashTable[hash].key!=0 && hash!=start){
            hash = (hash+1)%17;
        }
        if(hashTable[hash].key==0){
            System.out.println("record is deleted");
            return -1;
        }
        if(hash==start && hashTable[start].key!=key){
            System.out.println("record not found");
            return -1;
        }

        return hash;


    }

    public void delete(int key,Record[] hashTable){
        int hash = search(key,hashTable);
        hashTable[hash].key = -999;
        hashTable[hash].val = "";
    }
}
public class Main {


    public static void main(String[] args) {
	// write your code here
        Scanner sc = new Scanner(System.in);

        Record[] arr = {new Record(100,"abc"),new Record(94,"def"),new Record(77,"sdkhf"),new Record(56,"sdfs"),new Record(57,"sdfs"),new Record(73,"sfdge"),new Record(101,"ert"),new Record(111,"yuyt")};

        Record[] hashTable = new Record[20];

        int i;
        for(i=0;i<arr.length;i++){
            int mod = (arr[i].key)%17;
            int start = mod-1;

            while(hashTable[mod]!=null && hashTable[mod].key!=0 && mod!=start){
                mod = (mod+1)%17;
            }
            if(mod==start && hashTable[mod]!=null && hashTable[start].key!=0){
                System.out.println("no space");
                break;
            }
            hashTable[mod] = arr[i];
        }
        int cmd=0;
        while(cmd!=2){
            System.out.println("1.Search");
            System.out.println("2.delete");
            System.out.println("2.exit");
            cmd = sc.nextInt();
            if(cmd==1){
                int key = sc.nextInt();
                int index = new Record().search(key,hashTable);
                System.out.println("found at index "+index );
            }
            if(cmd==2){
                int key = sc.nextInt();
                new Record().delete(key,hashTable);
            }
        }
    }
}


// heap sort

public class Main {


    public static void main(String[] args) {
	// write your code here
        Scanner sc = new Scanner(System.in);

        int[] arr = {43,12,72,5,89,32,29,46,59};

        int i,temp,temp1,j;
        for(i=1;i<arr.length;i++){
            j=i;
            while(arr[j]>arr[(j-1)/2] && j>=0){
                temp=arr[j];
                arr[j] = arr[(j-1)/2];
                arr[(j-1)/2] = temp;
                j=(j-1)/2;
            }
        }
        System.out.println(Arrays.toString(arr));
        int count=arr.length-1;
        while(count>0){
            temp = arr[0];
            arr[0] = arr[count];
            arr[count]= temp;

            j=0;
            int k=0;
            while(2*j<count  && k<count && (arr[j]<arr[2*j] || arr[j]<arr[2*j+1])){
                k=0;
                if(arr[2*j]>=arr[2*j+1]){
                    k=2*j;
                }
                else {
                    k=2*j+1;
                }
                if(k<count) {
                    temp = arr[j];
                    arr[j] = arr[k];
                    arr[k] = temp;
                    j = k;
                }
            }


            count--;
        }
        System.out.println(Arrays.toString(arr));
    }
}


Trees

kl